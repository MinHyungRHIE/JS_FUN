# 01,02,03,04 생략

<br><br><br><hr>

# 05. 표현식과 문

## - 문

프로그램을 구성하는 기본단위이자 최소 실행 단위(명령문)

## - 표현식

값으로 평가될 수 있는 문(Statement)은 모두 표현식(Expression)이다.


<br><br><br><hr>

# 06,07,08 생략

<br><br><br><hr>

# 09. 타입 변환과 단축 평가

## - '+' 암묵적 타입변환

```js
+''         //0
+'0'        //0
+'1'        //1
+'string'   //NaN
  
+true       //1
+false      //0
  
+null       //0
+undefined  //0
+Symbol()   // "TypeError"

+{}                 //NaN
+[]                 //0
+[1,2]              //NaN
+(function(){})     //NaN
```

## - Falsy 암묵적 타입변환

 - false
 - undefined
 - null
 - 0, -0
 - NaN
 - ''

`isFalsy()`라는 함수로 Falsy면 true, Truthy면 false를 반환 받을 수 있음

## - `?.`(옵셔널 체이닝 연산자)

왼측 피연산자가 null이나 undefined면 undefined를 반환하고, 아니면 참조 진행

```js
let elem = null;

let value = elem?.value;
console.log(value) //undefined
```

## - `??`(null 병합 연산자)

ES11(ECMAScript2020)에서 도입된 null 병합 연산자

왼측 피연산자가 null이나 undefined인 경우 우측 피연산자의 반환값으로

```js
let foo = null ?? '문자열';
console.log(foo); //"문자열"
```

<br><br><br><hr>

# 10. 객체 리터럴

Before ES6
```js
const obj = {
    name : 'Rhie',
    sayHi : function() {
        console.log(`Hi! ${this.name}`);
    }
}

obj.sayHi();  // Hi! Rhie
```

After ES6
```js
const obj = {
    name : 'Rhie',
    
    //메서드 축약 표현
    sayHi(){
        console.log(`Hi! ${this.name}`);
    }
} 

obj.sayHi();  // Hi! Rhie
```


<br><br><br><hr>

# 11. 원시 값과 객체의 비교 & 12. 함수

## - Primitive Type(원시 값)은 immutable하다.

### * ex) 문자열은 immutable이다.

```js
let str = "string";
str[0] = "S";
console.log(str); // "string"
```

### * ex) 숫자값 전달시 메모리 재할당

```js
let score = 95;
let copy = score; //score의 주소값이 아니라 값이 전달되며 재할당

//score과 copy는 다른 주소값을 갖는다.
console.log(score) //95
console.log(copy) //95

score = 100;

//score의 값을 변경해도 copy에 영향이 없다.
console.log(score); //100
console.log(copy); //95
```

## - Reference Type

### * Shallow Copy & Deep Copy

### * 함수도 객체다

함수 객체가 다른 점은 일반 객체는 호출할 수 없는 반면에 함수는 호출할 수 있는 것이다.

## - 함수 

### * 함수 선언 방법

 - 함수 선언문

```js
function sum(n1, n2){
    return n1 + n2;
}
```

 - 함수 표현식

```js
let sum = function(n1, n2){
    return n1 + n2;
}
```
함수는 함수 자체가 값을 나타내거나 표현하는 것이 아니기 때문에 표현식이 아니다. 즉, 변수에 할당할 수 없는 것이다. 그러나 위와 같이 함수 선언문이 변수에 할당되는 것처럼 보인다.

 - Function 생성자 함수

```js
let sum = new Function('n1','n2','return n1 + n2');
```
클로저 생성 안함.

 - 화살표 함수(ES6)

```js
let sum = (n1, n2) => n1 + n2;
```
this 바인딩, prototype, arguments 객체가 없음.
#### 함수 선언문과 함수 표현식

```js
console.log(add(4,2)); //6

function add(x, y){
    return x + y;
}
```

```js
console.log(add(4,2)); //ReferenceError

let add = function(x, y){
    return x + y;
}
```
함수 호이스팅은 함수를 호출하기 전에 함수를 선언해야 한다는 규칙을 무시하므로 함수 표현식 사용을 권장한다고 한다.(더글라스 크락포드)

### * 매개변수 기본값

```js
function add(a, b, c){
    a = a || 0;
    b = b || 0;
    c = c || 0;
    return a + b + c
}
```
```js
function add(a = 0, b = 0, c = 0){
    return a + b + c
}
```
### * 반환문 생략시

반환문을 생략하면 암묵적으로 undefined가 반환된다.

### * IIFE

```js
let result = (function(x, y){
    return x + y;
})(10, 20);

console.log(result); //30
```

### * 순수함수와 비순수함수

외부 상태에 의존하지도 않고 외부 상태를 변경하지도 않는 부수 효과가 없는 함수를 `순수함수` 그 반대로 작용하면 `비순수함수`

<br><br><br><hr>

# 13. 스코프

스코프는 변수 이름의 충돌을 방지하여 같은 이름의 변수를 사용할 수 있게한다.

```js
let x = 10;

function foo(){
    let x = 5;
}

foo();

console.log(x); //10
```

## - 스코프 체인

### * 동적 스코프와 정적 스코프

 - `동적 스코프`라고 함 : 함수를 어디서 호출했는지에 따라 함수의 상위 스코프를 결정한다.

 - `정적 스코프` 또는 `렉시컬 스코프`라고 함 : 함수를 어디서 정의했는지에 따라 상위 스코프를 결정한다.

자바 스크립트는 렉시컬 스코프를 따르므로 함수를 어디서 호출했는지가 아니라 함수를 어디서 정의했는지에 따라 상위 스코프를 결정한다. 함수가 호출된 위치는 상위 스코프 결정에 어떠한 영향도 주지 않는다.

<br><br><br><hr>

# 14 생략

<br><br><br><hr>

# 15. let, const 키워드와 블록레벨 스코프

## - TDZ

```js
console.log(foo); //undefined
var foo;
console.log(foo); //undefined

foo = 1;
console.log(foo); //1
```

위 코드의 생명주기는 다음과 같다.

선언 단계와 초기화 단계가 동시에 이루어졌다.

그다음 `foo = 1`을 통해 할당 단계가 이루어졌다.

```js
console.log(foo) //ReferenceError
let foo; // 초기화 단계
console.log(foo) //undefined
foo = 1;
console.log(foo) //1
```
선언 단계와 TDZ(일시적 사각지대)까지 ReferenceError 발생

그 다음 초기화 단계와 할당 단계가 이루어진다.

<br><br><br><hr>

# 16. 프로퍼티 어트리뷰트

## - 디스크립터 객체
```js
const person = {
    name : 'Lee',
    age : 30
}

console.log(Object.getOwnPropertyDescriptor(person, 'name'));
//{value: "Lee", writable: true, enumerable: true, configurable: true}
console.log(Object.getOwnPropertyDescriptors(person));
/* 
{value: "Lee", writable: true, enumerable: true, configurable: true},
{value: 30, writable: true, enumerable: true, configurable: true}
*/
```

## - 데이터 어트리뷰트

 - value

접근하면 반환하는 값

 - writable

value 변경 가능 여부 

 - enumerable

열거 가능 여부, 불가능일 시 `Object.keys()`, `for문` 등으로 열거 불가

 - configurable

false일 시 프로퍼티 삭제 및 프로퍼티 어트리뷰트(프로퍼티 상태) 값의 변경이 금지된다. 단, writable이 true면 value의 변경과 writable을 false로 변경하는 건 허용한다.

## - 접근자 프로퍼티

 - get
 - set
 - enumerable : 데이터 프로퍼티와 같다.
 - configurable : 데이터 프로퍼티와 같다.

```js
const person = {
    name : "Rhie",
    age : 28,

    get info(){
        return `${this.name} : ${this.age}`
    },

    set info(infoObj){
        this.name = infoObj.name??this.name;
        this.age = infoObj.age??this.age;
    }
}

console.log(person.info); // Rhie : 28
person.info={
    name : "Eddie"
}
console.log(person.info); // Eddie : 28
```

### * 데이터 프로퍼티와 접근자 프로퍼티 구분

```js
Object.getOwnPropertyDescriptor(Object.prototype, '__proto__');
// 일반 객체의 __proto__는 접근자 프로퍼티

Object.getOwnProptertyDescriptor(function(){}, 'prototype'); 
// 함수 객체의 prototype은 데이터 프로퍼티
```

## - 정의

```js
Object.defineProperty(person, 'name', {
    value: 'rhie',
    writable: true,
    enumerable: true,
    configurable: true
})
```

## - immutable 객체

|구분|메서드|추가|삭제|읽기|쓰기|어트리뷰트 재정의|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|확장 금지|`Object.preventExtensions`|X|O|O|O|O|
|밀봉|`Object.seal`|X|X|O|O|X|
|동결|`Object.freeze`|X|X|O|X|X|

### * 확인

 - `Object.isExtensible()`
 - `Object.isSealed()`
 - `Object.isFrozen()`

<br><br><br><hr>

# 17. 생성자 함수에 의한 객체 생성

## - 내부 메서드 `[[Call]]`, `Constructor`

```js
function foo(){}

foo(); //[[Call]] 호출

new foo(); //[[Constructor]] 호출
```

## - 일반 함수 객체 반환

```js
function createUser(name, role){
    return {name , role}
}

let inst = new createUser('rhie','admin');
console.log(inst);
```

## - `new.target` || `scope-safe constructor`

```js
function Person(name, age){
    //이 함수가 new 연산자와 호출 되지 않으면 undefined임
    if(!new.target){
        return new Person(name, age);
    }
}
```

```js
function Person(name, age){
    if(!(this instanceof Person)){
        return new Person(name, age);
    }
}
```

<br><br><br><hr>

# 18. 함수와 일급 객체

## - arguments

Function.arguments는 ES3부터 표준에서 폐지됨

함수 내부에서 지역 변수처럼 사용하는 arguments 객체 참조하기

```js
function multiply(x, y){
    //이터레이터
    const iterator = arguments[Symbol.iterator]();s

    console.log(iterator.next()); // {value: 1, done: false}
    console.log(iterator.next()); // {value: 2, done: false}
    console.log(iterator.next()); // {value: 3, done: false}
    console.log(iterator.next()); // {value: undefined, done: true}

    return x * y;
}

multiply(1, 2, 3);
```

```js
function sum(){
    const array = Array.prototype.slice.call(arguments);
    return array.reduce(function(previous, previous){
        return previous + previous;
    }, 0)
}

console.log(sum(1, 2))          //3
console.log(sum(1, 2, 3, 4, 5)) //15
```

## - 함수의 name

```js
let nameFunc = function foo(){};
console.log(nameFunc.name); //foo
```

<br><br><br><hr>

# 19. 프로토타입

## - `[[Prototype]]`

모든 객체는 `[[Prototype]]`이라는 내부 슬롯을 가짐

`__proto__`는 `[[Prototype]]` 내부 슬롯이 가리키는 프로토타입 객체에 접근하는 용도

```js
const obj = {a: 1};
console.log(obj.__proto__ === Object.prototype); //true
```

```js
// 함수 객체는 prototype 프로퍼티를 소유한다.
(function() {}).hasOwnProperty('prototype'); //true

// 일반 객체는 prototype 프로퍼티를 소유하지 않는다.
({}).hasOwnProperty('prototype'); //false
```

### * 프로토타입 존재 이유

```js
function Circle(radius){
    this.radius = radius;
    this.getArea = function(){
        return Math.PI * this.radius ** 2;
    }
}

const c1 = new Circle(1);
const c2 = new Circle(2);

console.log(c1.getArea === c2.getArea); //false
```
메모리 낭비 발생

```js
function Circle(radius){
    this.radius = radius;
}

Circle.prototype.getArea = function(){
    return Math.PI * this.radius ** 2;
}

const c1 = new Circle(1);
const c2 = new Circle(2);

console.log(c1.getArea === c2.getArea); //true
```

![](./mdsrc/1.png)


### * 프로토타입 정보 얻기

`__proto__`로 접근하는 것보다는 `Object.getPrototypeOf`를 사용하는 것이 좋다.

```js
const obj = {};
const parent = { x : 1 };

Object.getPrototypeOf(obj); //obj.__proto__
Object.setPrototypeOf(obj, parent);

console.log(obj.x);
```

## - non-constructor
 - 화살표 함수와 메서드 축약 표현은 non-constructor이다.

```js
const Person = name => {
    this.name = name;
}

console.log(Person.hasOwnProperty('prototype')); // false
console.log(Person.prototype) // undefined

const obj = {
    foo(){}
}

console.log(obj.foo.hasOwnProperty('prototype')) //false
console.log(obj.foo.prototype) // undefined
```

## - 프로토타입 체인

![](./mdsrc/2.jpg)

## - Object.create()

### * 객체 생성

```js
//프로토타입이 object의 프로토타입인 객체를 생성한다.
let obj = Object.create(Object.prototype);
console.log(Object.getPrototypeOf(obj) === Object.prototype); //true

function Person(name){
    this.name = name;
}

// let me = new Person("rhie");
let me = Object.create(Person.prototype);
me.name = "rhie";
console.log(me.name) //rhie
console.log(me.getPrototypeOf(me) === Person.prototype) // true
```

## - 객체 상속

```js
const myProto = { x : 10 };

const obj = {
    y : 20,
    __proto__ : myProto
}

/* 
const obj = Object.create(myProto, {
    y : {value : 20, writable: true, enumerable : true, configurable: true}
})
*/
console.log(obj.x, obj.y); //10 20
```

## - static

```js
function Person(name){
    this.name = name;
}

//프로토타입 메서드
Person.prototype.sayHello = function(){
    console.log(`Hello~ my name is ${this.name}`);
}

Person.staticProperty = 'static 프로퍼티'
Person.staticMethod = function() {
    console.log('static 메서드');
}

const me = new Person('RHIE');

Person.staticMethod(); //static 메서드
me.staticMethod(); //TypeError 
```

## - 프로퍼티 확인

### * in

```js
const person = {
    name : "rhie",
    age : 10
}

console.log('name' in person); //true
console.log('gender' in person); //false
console.log('toString' in person); //true
```

여기서 `toString`이 true로 나온 이유는 in 연산자가 프로토타입 체인을 모두 훑기 때문이다.

### * Reflect.has

```js
const person = {name : 'rhie'};

console.log(Reflect.has(person, 'name')); //true
console.log(Reflect.has(person, 'toString')); //true
```

### * `Object.prototype.hasOwnProperty`

```js
const person = {name : 'rhie'};

console.log(person.hasOwnProperty('name')); //true
console.log(person.hasOwnProperty('toString')); //false
```

객체 고유의 프로퍼티 키인 경우에만 true를 반환하기 때문에 프로토타입이 상속받은 키인 경우에는 false를 반환한다.

## - 프로퍼티 열거

### * for...in문

```js
const sym = Symbol();
const person = {
    name : 'rhie',
    age : 10,
    __proto__ : { address : "seoul"}
    [sym] : 20
}

for (const key in person){
    console.log(`${key} : ${person[key]}`)
}
// name : rhie
// age : 10
// address : seoul
```

in 연산과 같이 상속받은 프로토타입의 프로퍼티까지 열거하지만 `Object.prototype`의 프로퍼티들이 열거되지 않은 이유는 이들의 `[[Enumerable]]`의 값이 false이기 때문이다.

또한, Symbol인 프로퍼티는 열거하지 않는다.

배열은 `for ...of`문이나 `Array.prototype.forEach`를 사용하는 것을 권장한다.

배열도 객체이므로 프로퍼티와 상속받은 프로퍼티가 포함될 수도 있기 때문에 요소가 아닌 프로퍼티를 제외할 필요성이 있기 때문이다.

```js
const arr = [1, 2, 3];
arr.x = 10;

for(const i in arr){
    console.log(arr[i]) // 1 2 3 10
}

console.log(arr.length) // 3

for (const value of arr){ //키가 아닌 값을 할당한다.
    console.log(value); //1 2 3
}
```

### * `Object.keys`, `Object.values`, `Object.entries`

```js
const person = {
    name : 'rhie',
    age : 10,
    __proto__ : { address : "seoul"}
}

console.log(Object.keys(person)) //["name", "age"]
console.log(Object.values(person)) //['rhie', 10]
console.log(Object.entries(person)); // [["name", "rhie"], ["age",10]]
```

<br><br><br><hr>

