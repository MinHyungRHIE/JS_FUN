###### 자바스크립트는 멀티패러다임 언어이다.

# 1. 변수
## - 파스칼 케이스
```js
var MyName;
```

<br><br><br>

## - 헝가리언 케이스
```js
var strName;
var $elem = document.getElementById("nav"); //DOM노드
var observabale$ = fromEvent(document, 'click'); //RxJS 옵저버블
```

<br><br><br>

## - 세미콜론 자동 삽입 기능(ASI, Automatic Semicolon Insertion)


<br><br><br>

## - 변수 선언 팁

```js
let x = 5, result;
console.log(result); //undefined
```

<br><br><br>

## - 암묵적 타입 변환

```js
'10' + 2 // '102'
5 * '10' // 50
```

<br><br><br>

## - 할당 스킬

```js
var done = true;
var message = done && '완료';
```

<br><br><br><br><br>
<hr>
<br><br><br><br><br>



# 2. 연산자와 제어문

## - if~else 축약형
```js
var x = 2, result;
//2 % 2는 0, 0은 암묵적으로 false로 변한다.
if(x % 2) result = '홀수';
else      result = '짝수';

console.log(result); //짝수
```

<br><br><br>

## - Optional Chaining `?.`

ES11(2020)에 도입 : null이나 undefined면 이걸 반환해

```js
var elem = null;

var value = elem?.value;
console.log(value); // undefined
```
 - `&&`와 비교

```js
var elem = null;

var value = elem && elem.value;
console.log(value); //null
```

```js
var str = '';

var length = str && str.length;

console.log(length); //''
```

 - Falsy(false, undefined, null, 0, NaN, '')라도 null 또는 undefined가 아니라면 프로퍼티 참조를 이어간다.
```js
var str = '';

var length = str?.length;
console.log(length); //0
```

<br><br><br>


## - Null 병합 연산자 `??` (nullish coalescing)

ES11(2020)에 도입 : null이나 undefined면 다른걸 반환해

```js
var foo = null ?? 'default string';
console.log(foo); // "default string"
```

<br><br><br>

## - switch 축약

```js
switch(month){
    case 1: case 3: case 5: case 7: case 8: case 10: case 12:
        days = 31;
        break;
    case 4: case 6: case 9: case 11:
        days = 30;
        break;
    case 2:
        days =((year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0)) ? 29 : 28;
        break;
    default:
        console.log("Invalid month");
}
```

<br><br><br><br><br>
<hr>
<br><br><br><br><br>

# 3. 객체

## - Primitive and Reference

 - 원시 타입 : immutable value
 - 객체 타입 : mutable value

### * 원시 값 <-> 래퍼 객체

래퍼 객체로 자동 변환되어 length 프로퍼티를 쓸 수 있게 된다.

```js
var str = 'string';

console.log(str.length); //6
```

<br><br><br>

## - 프로퍼티 축약 표현

```js
let x = 1, y = 2;

const obj = {x, y};

console.log(obj); //{x: 1, y: 2}
```

<br><br><br>

## - Function 생성자
이렇게 생성한 함수는 클로저를 생성하지 않는다.
```js
/*
var add = function(x, y){
    return x + y;
};
*/

var add = new Function('x','y','return x + y');
```

<br><br><br>

## - 화살표 함수
 - 생성자 함수로 사용할 수 없다.
 - this 바인딩 방식이 다르다.
 - prototype 프로퍼티가 없다.
 - arguments 객체를 생성하지 않는다.

<br><br><br>

## - 함수 기본값
인수를 전달하지 않았을 경우와 undefined를 전달한 경우에 유효

```js
function add(a = 0, b = 0){
    return a + b;
}
```

<br><br><br>

## - 좋은 함수는...
이상적인 함수는 한 가지 일만 해야 하며 가능하면 작게 만들어야 한다.

<br><br><br>

## - 외부 함수와 내부 함수
내부함수는 보통 외부 함수를 돕는 `Helper Function`의 역할을 함
```js
function outer(){
    function inner(){

    }
}
```

<br><br><br>

## - 콜백 함수(callback function)
함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수

매개변수를 통해 함수의 외부에서 콜백 함수를 전달 받는 함수를 고차 함수라고 한다
 - Higher-Order Function, HOF

<br><br><br>

## - 순수함수와 비순수함수

 - 순수 함수 : 외부 상태에 의존하지도 않고 변경하지도 않음
 - 비순수 함수 : 외부 상태에 의존하고 외부 상태를 변경함

외부 상태를 변경한다 == 사이드 이펙트가있다.

